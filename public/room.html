<!doctype html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Pair Riddle — Room</title>
    <style>
      body{font-family:system-ui,Segoe UI,Arial;background:#f6f8fa;padding:12px}
      .card{max-width:900px;margin:0 auto;background:#fff;padding:18px;border-radius:8px}
      .board{background:#eef2f7;border:1px solid #d8e0ea;border-radius:8px;padding:12px}
    .board.grid{display:grid;grid-template-columns:repeat(7,60px);grid-auto-rows:60px;gap:8px;justify-content:center;padding:12px}
    .rune{display:flex;width:60px;height:60px;border-radius:8px;background:#ffd966;margin:0;align-items:center;justify-content:center;cursor:pointer;transition:transform .12s, box-shadow .12s, background .12s}
    .rune.selected{background:#8fd19e;box-shadow:0 4px 8px rgba(0,0,0,0.08);transform:translateY(-3px)}
    .rune.highlighted{background:#a3e9a8;box-shadow:0 6px 12px rgba(0,0,0,0.08);transform:translateY(-3px)}
    .rune.green{background:#a3e9a8}
    .rune.red{background:#f7a6a6}
    .rune.blue{background:#a6c8f7}
    .board.active-green{border:3px solid #a3e9a8}
    .board.active-red{border:3px solid #f7a6a6}
    .board.active-blue{border:3px solid #a6c8f7}
    .rune.hint-correct{box-shadow:0 0 0 4px rgba(120,200,255,0.35), 0 6px 12px rgba(0,0,0,0.08);transform:translateY(-2px)}
    .rune.hint-mismatch{box-shadow:0 0 0 6px rgba(255,80,80,0.35), 0 6px 12px rgba(0,0,0,0.12);transform:translateY(-2px)}
    .row-indicator-col{display:flex;flex-direction:column;gap:8px;margin-right:12px}
    .row-indicator{width:20px;height:60px;border-radius:6px;background:transparent;border:1px solid #ddd}
    .row-indicator.green{background:#a3e9a8;border-color:#7fcf82}
    .row-indicator.red{background:#f7a6a6;border-color:#f28b8b}
    .row-indicator.blue{background:#a6c8f7;border-color:#7faee6}
      .hint{background:#f3f6ff;padding:12px;border-radius:6px;margin:8px 0}
    </style>
  </head>
  <body>
    <div id="app" class="card"></div>

    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <script type="text/babel">
      const { useEffect, useRef, useState } = React;

      function App(){
        const params = new URLSearchParams(window.location.search);
        const seedParam = params.get('seed');
        const playerParam = params.get('player') || 'player1';
        const nameParam = params.get('name') || '';
        const timeParam = Number(params.get('time')) || 180;
        const gameJsonPath = '/game.json';
        const logicPath = '/logic.js';
        const themeParam = params.get('theme') || 'rune';

        const [name, setName] = useState(nameParam);
        const [status, setStatus] = useState('ready');
        const [riddleIndex, setRiddleIndex] = useState(0);
        const [round, setRound] = useState(0);
        const [riddleContent, setRiddleContent] = useState(null);
        const [sequence, setSequence] = useState([]);
        const [showPassword, setShowPassword] = useState(false);
        const [showCorrect, setShowCorrect] = useState(false);
        const [passwordInput, setPasswordInput] = useState('');
        const [timerEndAt, setTimerEndAt] = useState(null);
        const [timerRemaining, setTimerRemaining] = useState(null);
        
        const answerRef = useRef();

        // load level files
        const [levelData, setLevelData] = useState(null);
        useEffect(()=>{
          fetch(gameJsonPath).then(r=>r.json()).then(g=>{
            // game.json contains { player1: [...], player2: [...] }
            setLevelData({ player1: g.player1 || [], player2: g.player2 || [] });
          }).catch(()=>{});
        }, []);

        // load level-specific logic script and let it prepare generated data
        const [levelLogic, setLevelLogic] = useState(null);
        const [generatedData, setGeneratedData] = useState(null);
        const [themes, setThemes] = useState(null);

        useEffect(()=>{
          if (!levelData) return;
          // load the level logic script from the level folder
          const script = document.createElement('script');
          script.src = logicPath;
          script.async = true;
          script.onload = () => { setLevelLogic(window.levelLogic || null); };
          document.body.appendChild(script);
          return ()=> { try{ document.body.removeChild(script); }catch(e){} };
        }, [levelData]);

        useEffect(()=>{
          if (!levelLogic || !seedParam || !levelData || !themes) return;
          const seed = decodeURIComponent(seedParam);
          const gen = levelLogic.prepare({ seed, levelData: levelData.player1, themes, theme: themeParam, round });
          setGeneratedData(gen);
        }, [levelLogic, seedParam, levelData, themes, themeParam, round]);

        // load themes config
        useEffect(()=>{
          fetch('/themes.json').then(r=>r.json()).then(t=>setThemes(t)).catch(()=>setThemes(null));
        }, []);

        // start riddle locally
        function startRiddle(idx){
          if (!levelData) return;
          setRiddleIndex(idx);
          setRound(0);
          const content = (playerParam === 'player1') ? levelData.player1[idx] : levelData.player2[idx];
          // if player2, craft hint based on generated data
          if (playerParam === 'player2') {
            const expected = (generatedData && ((generatedData.expectedSequences && generatedData.expectedSequences[idx]) || (generatedData.expectedIndices && (generatedData.expectedIndices[idx] || generatedData.expectedIndices)))) || [];
            const themeList = (themes && themes[themeParam]) || [];
            // determine grid size for this riddle (generatedData preferred, then riddle JSON gridSize, then default)
            const gridSizeForHint = (generatedData && generatedData.gridSizes && generatedData.gridSizes[idx]) || (levelData.player1[idx].gridSize) || 7;
            const objCountForHint = gridSizeForHint * gridSizeForHint;
            // build rune labels fallback array of length objCountForHint
            const runeLabels = Array.from({length: objCountForHint}, (_, i) => {
              const fromGen = (generatedData && generatedData.labelsPerRiddle && generatedData.labelsPerRiddle[idx] && generatedData.labelsPerRiddle[idx][i]) || (generatedData && generatedData.labelsPerRiddlePlayer2 && generatedData.labelsPerRiddlePlayer2[idx] && generatedData.labelsPerRiddlePlayer2[idx][i]);
              if (fromGen) return fromGen;
              if (levelData.player1[idx].emoji && levelData.player1[idx].emoji[i]) return levelData.player1[idx].emoji[i];
              if (themeList && themeList[i]) return themeList[i];
              return `#${i+1}`;
            });
            const parts = expected.map((i, pos) => `#${pos+1}=${runeLabels[i] || ('r'+i)}`);
            const chosen = (generatedData && ((generatedData.chosenAnswers && generatedData.chosenAnswers[idx]) || generatedData.chosenAnswers)) || null;
            const answerHint = chosen ? `(password is one of the game's words)` : '';
            const hintText = (content && content.hint) ? content.hint + '\n' + 'Hint: ' + parts.join(' -> ') + ' ' + answerHint : 'Hint: ' + parts.join(' -> ') + ' ' + answerHint;
            setRiddleContent(Object.assign({}, content, { hint: hintText }));
          } else {
            setRiddleContent(content);
          }
          setSequence([]);
          // start timer for this riddle
          const endAt = Date.now() + timeParam*1000;
          setTimerEndAt(endAt);
          setStatus('playing');
          
        }

        // clear password input when riddle changes
        useEffect(()=>{ setPasswordInput(''); }, [riddleIndex]);

        // countdown
        useEffect(()=>{
          if (!timerEndAt) { setTimerRemaining(null); return; }
          const tick = () => {
            const rem = Math.max(0, Math.ceil((timerEndAt - Date.now())/1000));
            setTimerRemaining(rem);
          };
          tick();
          const iv = setInterval(tick, 500);
          return ()=> clearInterval(iv);
        }, [timerEndAt]);

        // show correct expected fields for 3s when user presses 'q' (player1 only)
        const revealTimeoutRef = useRef(null);
        useEffect(()=>{
          function onKey(e){
            if ((e.key || '').toLowerCase() !== 'q') return;
            if (playerParam !== 'player1') return;
            if (!generatedData) return;
            // toggle/activate reveal
            if (revealTimeoutRef.current) {
              clearTimeout(revealTimeoutRef.current);
              revealTimeoutRef.current = null;
            }
            setShowCorrect(true);
            revealTimeoutRef.current = setTimeout(()=>{
              setShowCorrect(false);
              revealTimeoutRef.current = null;
            }, 3000);
          }
          window.addEventListener('keydown', onKey);
          return ()=>{
            window.removeEventListener('keydown', onKey);
            if (revealTimeoutRef.current) clearTimeout(revealTimeoutRef.current);
          };
        }, [playerParam, generatedData]);

      // helper: produce the label that would be shown for a given player and cell
      function computeLabelFor(player, ridx, i, gridSize) {
        if (!generatedData || !levelData) return null;
        // prefer per-player generated labels when available
        if (player === 'player2' && generatedData.labelsPerRiddlePlayer2 && generatedData.labelsPerRiddlePlayer2[ridx]) {
          const arr2 = generatedData.labelsPerRiddlePlayer2[ridx] || [];
          if (arr2[i]) return arr2[i];
        }
        const labelsArr = (generatedData.labelsPerRiddle && generatedData.labelsPerRiddle[ridx]) || [];
        if (labelsArr && labelsArr[i]) return labelsArr[i];
        // fallback to per-player emoji or theme
        const themeList = (themes && themes[themeParam]) || [];
        const rc = (levelData.player1 && levelData.player1[ridx]) || {};
        const emojiList = (rc.emoji && rc.emoji.length) ? rc.emoji : themeList;
        return (emojiList && emojiList[i]) ? emojiList[i] : (`#${i+1}`);
      }

        // handle timeout
        useEffect(()=>{
          if (timerRemaining === null) return;
          if (timerRemaining <= 0 && status === 'playing') {
            setStatus('lost');
          }
        }, [timerRemaining, status]);

        function onRuneClick(i){
          if (playerParam !== 'player1' || status !== 'playing' || showPassword) return;
          if (levelLogic && generatedData) {
            const res = levelLogic.onRuneClick({ riddleIndex, sequence, showPassword, generated: generatedData }, i);
            if (res && Array.isArray(res.sequence)) setSequence(res.sequence);
            if (res && res.showPassword) setShowPassword(true);
            return;
          }
          // fallback to simple local handling (shouldn't be needed when level logic loaded)
          const newSeq = [...sequence, i];
          setSequence(newSeq);
          const expected = (generatedData && generatedData.expectedSequences && generatedData.expectedSequences[riddleIndex]) || [];
          if (newSeq.length >= expected.length) {
            const correct = newSeq.join(',') === expected.join(',');
            if (correct) {
              setShowPassword(true);
            }
          }
        }

        function submitAnswer(){
          if (!levelData) return;
          // reading from text input (for non-selection riddles)
          const val = (arguments.length && typeof arguments[0] === 'string') ? arguments[0].trim() : (answerRef.current && answerRef.current.value || '').trim();
          // if level logic present and this is a text submission, delegate
          if (levelLogic && generatedData && val) {
            const ok = levelLogic.submitAnswer({ riddleIndex, generated: generatedData, levelData: levelData.player1, sequence }, val);
            if (ok) {
              // if in progressive rounds, increase round first (stay on same riddle)
              if (round < 3) {
                setRound(r => r + 1);
                setSequence([]);
                setShowPassword(false);
                setTimerEndAt(Date.now() + timeParam*1000);
                setStatus('playing');
              } else {
                const next = riddleIndex + 1;
                if (next < levelData.player1.length) startRiddle(next);
                else { setStatus('finished'); }
              }
            }
            if (answerRef.current) answerRef.current.value = '';
            setPasswordInput('');
            return;
          }
          // fallback simple check when no levelLogic
          const expectedAnswer = (generatedData && generatedData.chosenAnswers && generatedData.chosenAnswers[riddleIndex]) || ((levelData.player1[riddleIndex].answer || '').toLowerCase());
          const given = val.toLowerCase();
          if (expectedAnswer && val && (given === 'test' || given === expectedAnswer)) {
            if (round < 3) {
              setRound(r => r + 1);
              setSequence([]);
              setShowPassword(false);
              setTimerEndAt(Date.now() + timeParam*1000);
              setStatus('playing');
            } else {
              const next = riddleIndex + 1;
              if (next < levelData.player1.length) startRiddle(next);
              else { setStatus('finished'); }
            }
          }
          if (answerRef.current) answerRef.current.value = '';
          setPasswordInput('');
        }

        function confirmSelection(){
          if (!levelLogic || !generatedData) return;
          const ok = levelLogic.submitAnswer({ riddleIndex, generated: generatedData, levelData: levelData.player1, sequence }, undefined);
          if (ok) {
            const next = riddleIndex + 1;
            if (next < levelData.player1.length) startRiddle(next);
            else { setStatus('finished'); }
          } else {
            // keep playing; maybe provide feedback later
          }
        }

        function resetSequence(){
          if (levelLogic) {
            const res = levelLogic.resetSequence();
            if (res && Array.isArray(res.sequence)) setSequence(res.sequence);
            setShowPassword(!!(res && res.showPassword));
            return;
          }
          setSequence([]);
          setShowPassword(false);
        }

        function continueNext(){
          // advance to next round/level: if current round < 3 increase round (bigger grid), otherwise go to next riddle
          if (!levelData) return;
          if (round < 3) {
            // increase round to get bigger grid for same riddle
            setRound(r => r + 1);
            // reset selection and hide password for next sub-round
            setSequence([]);
            setShowPassword(false);
            // restart timer for the new sub-round
            setTimerEndAt(Date.now() + timeParam*1000);
            setStatus('playing');
            return;
          }
          const next = riddleIndex + 1;
          if (next < levelData.player1.length) startRiddle(next);
          else { setStatus('finished'); }
        }

        return (
          <div>
        
            {status === 'ready' && (
              <div style={{marginTop:12}}>
                  <button onClick={()=>startRiddle(0)} disabled={!(levelData && levelData.player1 && levelData.player1.length)}>Start Game</button>
                  <div style={{marginTop:8}}>Per-riddle time: {timeParam}s (from link)</div>
                </div>
            )}

            {(status === 'playing' || status === 'lost' || status === 'finished') && (
              <div style={{marginTop:12}}>
                
                {playerParam === 'player1' ? (
                  riddleContent && (
                    <div>
                      {(() => {
                          // gridSize: prefer generatedData, then riddle JSON gridSize, then infer from descriptiveObjects length, then default
                          const gridSize = (generatedData && generatedData.gridSizes && generatedData.gridSizes[riddleIndex]) || (riddleContent.gridSize) || Math.sqrt((riddleContent.descriptiveObjects || riddleContent.runes || []).length) || 7;
                          const objCount = gridSize * gridSize;
                          const allSource = (riddleContent.descriptiveObjects || riddleContent.runes) || [];
                          const objs = Array.from({length: objCount}, (_,i) => allSource[i] || null);
                          const themeList = (themes && themes[themeParam]) || [];
                          const emojiList = (riddleContent.emoji && riddleContent.emoji.length) ? riddleContent.emoji : themeList;
                          const boardClass = 'board grid';
                          const requiredCount = (generatedData && generatedData.expectedSequences && generatedData.expectedSequences[riddleIndex]) ? generatedData.expectedSequences[riddleIndex].length : (riddleContent.sequenceLength || 0);
                          // compute per-column color indicator from colColorMaps
                          const colMap = (generatedData && generatedData.colColorMaps && generatedData.colColorMaps[riddleIndex]) || [];
                          const colColors = Array.from({length:gridSize}, (_,c)=>{
                            for (let j = c; j < Math.min(colMap.length, objs.length); j += gridSize) {
                              if (colMap[j]) return colMap[j];
                            }
                            return null;
                          });
                          const rowMap = (generatedData && generatedData.rowColorMaps && generatedData.rowColorMaps[riddleIndex]) || [];
                          const rowColors = Array.from({length:gridSize}, (_,r)=>{
                            for (let j = r*gridSize; j < Math.min(r*gridSize+gridSize, rowMap.length); j++) {
                              if (rowMap[j]) return rowMap[j];
                            }
                            return null;
                          });
                        return (
                          <div>
                            <div style={{display:'flex',justifyContent:'center',marginBottom:8}}>
                              <div style={{width: (gridSize*60 + (gridSize-1)*8) }}>
                                <div style={{display:'flex',gap:8,justifyContent:'center'}}>
                                  {colColors.map((c,ci)=> (
                                    <div key={ci} className={"row-indicator" + (c ? (' ' + c) : '')} style={{width:60,height:20,borderRadius:6}} title={c ? (c + ' column') : 'no color'} />
                                  ))}
                                </div>
                              </div>
                            </div>

                            <div style={{display:'flex',alignItems:'flex-start',justifyContent:'center'}}>
                              <div style={{display:'flex',flexDirection:'column',height:(gridSize*60 + (gridSize-1)*8),marginRight:12,justifyContent:'center',gap:8}}>
                                {rowColors.map((c,ri)=> (
                                  <div key={ri} className={"row-indicator" + (c ? (' ' + c) : '')} style={{width:20,height:60,borderRadius:6}} title={c ? (c + ' row') : 'no color'} />
                                ))}
                              </div>
                              <div>
                                <div className={boardClass} style={{gridTemplateColumns: `repeat(${gridSize},60px)`, gridAutoRows: '60px'}}>
                                  {objs.map((r,i)=> {
                                    const seedLabel = computeLabelFor('player1', riddleIndex, i, gridSize);
                                    const label = seedLabel || ((r && r.label) ? r.label : (emojiList && emojiList[i]) ? emojiList[i] : '?');
                                    const isSelected = sequence && sequence.includes(i);
                                    const expected = (generatedData && generatedData.expectedSequences && generatedData.expectedSequences[riddleIndex]) || [];
                                    const isCorrect = expected && expected.includes(i);
                                    // treat the deterministic mismatch index as an expected cell for the purposes of Q-reveal
                                    const mismatchIdx = (generatedData && generatedData.mismatchIndices && generatedData.mismatchIndices[riddleIndex] !== undefined) ? generatedData.mismatchIndices[riddleIndex] : null;
                                    const isExpectedOriginal = isCorrect || (mismatchIdx !== null && mismatchIdx === i);
                                    // detect label mismatch between player1 and player2 views for this cell
                                    // reuse gridSize from outer scope
                                    const label1 = computeLabelFor('player1', riddleIndex, i, gridSize);
                                    const label2 = computeLabelFor('player2', riddleIndex, i, gridSize);
                                    const isMismatch = (label1 !== null && label2 !== null && String(label1) !== String(label2));
                                    const cls = 'rune' + (isSelected ? ' selected' : '') + (showCorrect && isExpectedOriginal ? (isMismatch ? ' hint-mismatch' : ' hint-correct') : '');
                                    return (<div key={i} className={cls} onClick={()=>onRuneClick(i)}>{label}</div>);
                                  })}
                                </div>
                                
                              </div>
                            </div>
                          </div>
                        );
                      })()}
                      <div style={{marginTop:8}}>
                        {!(playerParam === 'player1') && (
                          <button onClick={resetSequence}>Reset Sequence</button>
                        )}
                        {showPassword && (
                          <div style={{marginTop:8,textAlign:'center'}}>
                            <div><strong>Password</strong></div>
                            <div style={{marginTop:6}}>{(generatedData && ((generatedData.chosenAnswers && generatedData.chosenAnswers[riddleIndex]) || generatedData.chosenAnswers))}</div>
                            <div style={{marginTop:8}}>
                              <button onClick={continueNext}>Continue</button>
                            </div>
                          </div>
                        )}
                        {/* Confirm button for selection-based levels (hidden for player1 level1) */}
                        {(generatedData && generatedData.confirmRequired && !(playerParam === 'player1')) && (
                          <button onClick={confirmSelection} style={{marginLeft:12}}>Confirm</button>
                        )}
                      </div>
                    </div>
                  )
                ) : (
                  riddleContent && (
                    <div>
                      {/* hint text removed for player2; UI is visual-only */}
                      {/* show objects grid for player2 and highlight expected ones */}
                      {generatedData ? (
                        (() => {
                          const gridSize = (generatedData && generatedData.gridSizes && generatedData.gridSizes[riddleIndex]) || (levelData.player1[riddleIndex].gridSize) || Math.sqrt(((levelData.player1[riddleIndex].descriptiveObjects || levelData.player1[riddleIndex].runes) || []).length) || 7;
                          const objCount = gridSize * gridSize;
                          const allSource = (levelData.player1[riddleIndex].descriptiveObjects || levelData.player1[riddleIndex].runes) || [];
                          const objs = Array.from({length: objCount}, (_,i) => allSource[i] || null);
                          const themeList = (themes && themes[themeParam]) || [];
                          const emojiList = (levelData.player1[riddleIndex].emoji && levelData.player1[riddleIndex].emoji.length) ? levelData.player1[riddleIndex].emoji : themeList;
                          const colorMap = (generatedData.colorMaps && generatedData.colorMaps[riddleIndex]) || [];
                          const activeColor = (generatedData && generatedData.activeColors && generatedData.activeColors[riddleIndex]) || null;
                          const boardClass2 = 'board grid' + (activeColor ? (' active-' + activeColor) : '');
                          return (
                            <div className={boardClass2} style={{gridTemplateColumns: `repeat(${gridSize},60px)`, gridAutoRows: '60px'}}>
                              {objs.map((r,i)=>{
                                const seedLabel = computeLabelFor('player2', riddleIndex, i, gridSize);
                                const label = seedLabel || ((r && r.label) ? r.label : (emojiList && emojiList[i]) ? emojiList[i] : '?');
                                const color = colorMap && colorMap[i];
                                const cls = "rune" + (color ? (' ' + color) : '');
                                return (<div key={i} className={cls}>{label}</div>);
                              })}
                            </div>
                          );
                        })()
                        ) : (
                        (() => {
                          const gridSize = (riddleContent && ((riddleContent.gridSize) || Math.sqrt((riddleContent.descriptiveObjects || riddleContent.runes || []).length))) || 7;
                          const objCount = gridSize * gridSize;
                          const allSource = (riddleContent.descriptiveObjects || riddleContent.runes) || [];
                          return (<div className="board grid" style={{gridTemplateColumns: `repeat(${gridSize},60px)`, gridAutoRows: '60px'}}>{Array.from({length: objCount}, (_,i)=> (
                            <div key={i} className="rune">{(allSource[i] && allSource[i].label) || '?'}</div>
                          ))}</div>);
                        })()
                      )}
                    </div>
                  )
                )}

                <div style={{marginTop:8,textAlign:'center',fontSize:18}}>{timerRemaining !== null ? `${timerRemaining}s` : '—'}</div>
                <div style={{marginTop:12}}>
                  {!(playerParam === 'player1' && riddleContent && riddleContent.sequenceLength) ? (
                    <span>
                      {playerParam === 'player2' ? (
                        // Player 2: controlled password input + Continue button (requires correct password)
                        <div style={{textAlign:'center'}}>
                          <label style={{display:'block',marginBottom:6}}>Password <input value={passwordInput} onChange={e=>setPasswordInput(e.target.value)} /></label>
                          <button
                            onClick={()=>submitAnswer(passwordInput)}
                            style={{}}
                            disabled={!(() => {
                              const val = (passwordInput || '').trim().toLowerCase();
                              if (!val) return false;
                              if (val === 'test') return true;
                              const expectedAnswer = (generatedData && generatedData.chosenAnswers && generatedData.chosenAnswers[riddleIndex]) || ((levelData && levelData.player1 && levelData.player1[riddleIndex] && levelData.player1[riddleIndex].answer) || '').toLowerCase();
                              return expectedAnswer && val === String(expectedAnswer).toLowerCase();
                            })()}
                          >Continue</button>
                        </div>
                      ) : (
                        <span>
                          <label>Answer: <input ref={answerRef} /></label>
                          <button onClick={submitAnswer} style={{marginLeft:8}}>Submit</button>
                        </span>
                      )}
                    </span>
                  ) : null}
                </div>
              </div>
            )}

            {status === 'lost' && <div style={{marginTop:12,color:'red'}}><strong>Game Over — time expired</strong></div>}
            {status === 'finished' && <div style={{marginTop:12,color:'green'}}><strong>All riddles complete</strong></div>}

            
          </div>
        );
      }

      ReactDOM.createRoot(document.getElementById('app')).render(React.createElement(App));
    </script>
  </body>
</html>